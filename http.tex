% !TEX root = main.tex
\section{The OpenCPU API}

This section introduces the most important concepts and operations of the \OpenCPU \API. At this point the general concerns become more concrete as we illustrate how the pieces come together in the context of \R and \HTTP. The intention of this paper is not to describe every feature of the system in great detail. The online documentation and reference implementations are the best source of information on the specifics of implementing clients and applications. This paper serves as a conceptual introduction, and focuses on the main parts of the interface that exemplify the separation of concerns central to this work. 

%The parts that were left out of the interface specification are just as interesting as the \API itself. For example the \RPC mechanism implies that concerns of managing processes, hardware and security are at the discretion of the server. Moreover, because clients can specify the data interchange format for retrieving an arbitrary resource, the server needs to implement mappings between the various resource types and data interchange formats. And the fact that computational exceptions are returned using \HTTP status codes implies that error handling is the responsibility of the client. These are some examples of how the \API implicitly gives rise to the boundaries for separation concerns and suggest a minimal structure for embedded scientific computing. 

\subsection{On HTTP}

One of the major strengths of \OpenCPU is that it builds on the hypertext transfer protocol. \HTTP is the most used application protocol on the internet, and the foundation of data communication in browsers and the world wide web. The \HTTP specification is very mature and widely implemented. It provides all functionality required to build modern applications and has recently gained popularity for web \API's as well. The benefit of using a standardized application protocol such as \HTTP is that a lot of funtionality gets built-in by design. \HTTP has excellent mechanisms for authentication, encryption, caching, distribution, concurrency, error handling, etc. This allows us to defer most appliation logic of our system to the protocol and limit the \API specification to logic of scientific computing. 

The \OpenCPU \API defines a mapping between \HTTP requests and high-level operations such as calling functions, running scripts, access to data, manual pages and management of files and objects. The \API specifically does not prescribe any language implementation details. Syntax and low-level concerns such as process management or code evaluation are abstracted and at the discretion of the server implementation. The \API also does not describe any logic which can be taken care of on the protocol or application layer. For example, to add support for authentication, any of the standard mechanisms can be used such as \texttt{basic auth} \citep{franks1999rfc} or \texttt{OAuth 2.0} \citep{hardt2012oauth}. The implementation of such authentication methods might vary from a simple server configuration to defining additional endpoints. However authentication will not affect the meaning of the \API itself and can therefore considered independent of this research. The same holds for other native features of the \HTTP protocol which can be used in conjunction with the \OpenCPU \API (or any other \HTTP \API for that matter). What remains after cutting away implementation and application logic is a simple and interoperable interface that is easy to understand and can be implemented with standard \HTTP software libraries. This is an enormous advantage over many other bridges to \R and critical to make the system scalable and extensible. 

\input{resource_types}

\subsection{Methods}

The current \API uses two \HTTP methods: \GET and \POST. As per \HTTP standards, \GET is a \emph{safe} method which means it is intended only for information retrieval and should not change the state of the server. The \GET method is used to retrieve objects, manuals, graphics or files. The parameters of the request are mapped to the formatting function. A \GET requests targeting a container, namespace or directory is used to list the contents. The \POST method on the other is used for \RPC which does change the server state. A \POST request targeting a function results in a remote function call where the \HTTP parameters are mapped to function arguments. A \POST request targeting a script results in an execution of the script where \HTTP parameters are mapped to the script interpreter. Table \ref{table:methods} gives an overview of these uses, which uses the \texttt{MASS} package \citep{MASS} as an example.

\begin{table}[H]
\centering
\def\arraystretch{1.3}%
\begin{tabular}{@{}lllll@{}}
\toprule
\emph{Method} & \emph{Target} & \emph{Action}  & \emph{Parameters}     & \emph{Example}                                      \\ \midrule
\texttt{GET}    & object  & retrieve      &  formatting     & \texttt{GET /ocpu/library/datasets/R/mtcars/json}            \\
                & manual  & read          &  formatting     & \texttt{GET /ocpu/library/MASS/man/rlm/html}            \\  
                & graphic & render        &  formatting    & \texttt{GET /ocpu/tmp/\{key\}/graphics/1/png}            \\   
                & file    & download      & -                     & \texttt{GET /ocpu/library/MASS/NEWS}                         \\
                & path    & list contents & -                     & \texttt{GET /ocpu/library/MASS/scripts/}                     \\ \midrule
\texttt{POST}   & object  & call function & function arguments    & \texttt{POST /ocpu/library/stats/R/rnorm}                    \\
                & file    & run script    & control interpreter   & \texttt{POST /ocpu/library/MASS/scripts/ch01.R}              \\ \bottomrule
\end{tabular}
\caption{Currently implemented \HTTP methods}
\label{table:methods}
\end{table}

\subsection{Status codes}

Each \HTTP response includes a status code. Table \ref{table:statuscodes} lists some common \HTTP status codes used by \OpenCPU that the client should be able to interpret. The meaning of these status codes is conform \HTTP standards. The web server might use additional status codes that are not specific to \OpenCPU for more general purposes.

\begin{table}[H]
\centering
\def\arraystretch{1.3}%
%\noindent\begin{tabular}{\columnwidth}{ *{3}{X} }
\begin{tabular}{@{}lll@{}}
\toprule
\emph{Status Code}              & \emph{Happens when}                             & \emph{Response content}                     \\ \midrule
\texttt{200 OK}          & On successful \texttt{GET} request                     & Requested data                    \\
\texttt{201 Created}     & On successful \texttt{POST} request                    & Output key and location                     \\
\texttt{302 Found}       & Redirect                                               & Redirect location                   \\
\texttt{400 Bad Request} & On computational error in \R                                     & Error message in \texttt{text/plain} \\
\texttt{502 Bad Gateway} & Back-end server offline                            & -- (See error logs) \\
\texttt{503 Bad Request} & Back-end server failure                                & -- (See error logs) \\ \bottomrule                          
\end{tabular}
\caption{Commonly used \HTTP status codes}
\label{table:statuscodes}
\end{table}

\subsection{Content-types}

Clients can retrieve objects on the server in various \emph{formats} by postfixing the object \URL with the format identifier in the \GET request. Which formats are supported and how object types are mapped to a particular format is at the discretion of the server implementation. Not every format has to support any object type. For example, \texttt{csv} can only be used to retrieve tabular data structures, and \texttt{png} is only appropriate for graphics. Table \ref{table:formats} lists the formats \OpenCPU supports, their standard internet media type identifier, and the \R function that our implementation uses to export an object into a particular format. Arguments of the \GET requests are mapped to the respective export function. For example the \texttt{png} format has parameters such as \texttt{width} and \texttt{height}, whereas the \texttt{tab delimited} format has parameters \texttt{sep}, \texttt{eol}, \texttt{dec} which specify the delimiting, end-of-line and decimal character respectively.

\begin{table}[H]
\centering
\def\arraystretch{1.3}%
\begin{tabular}{@{}lllll@{}}
\toprule
 \emph{Format} & \emph{Content-type}             & \emph{Export function}      & \emph{Example}    \\ \midrule
 \texttt{print}  & \texttt{text/plain}               & \texttt{base::print}    & \texttt{/ocpu/cran/MASS/R/rlm/print}          \\
 \texttt{rda}    & \texttt{application/octet-stream} & \texttt{base::save}     & \texttt{/ocpu/cran/MASS/data/cats/rda}          \\
 \texttt{rds}    & \texttt{application/octet-stream} & \texttt{base::saveRDS}  & \texttt{/ocpu/cran/MASS/data/cats/rds}          \\
 \texttt{json}   & \texttt{application/json}         & \texttt{jsonlite::toJSON}   & \texttt{/ocpu/cran/MASS/data/cats/json}      \\
 \texttt{pb}     & \texttt{application/x-protobuf}   & \texttt{RProtoBuf::serialize\_pb} & \texttt{/ocpu/cran/MASS/data/cats/pb} \\
 \texttt{tab}    & \texttt{text/plain}               & \texttt{utils::write.table}   & \texttt{/ocpu/cran/MASS/data/cats/tab}    \\
 \texttt{csv}    & \texttt{text/csv}                 & \texttt{utils::write.csv}    & \texttt{/ocpu/cran/MASS/data/cats/csv}     \\
 \texttt{png}    & \texttt{image/png}                & \texttt{grDevices::png}      & \texttt{/ocpu/tmp/\{key\}/graphics/1/png}    \\
 \texttt{pdf}    & \texttt{application/pdf}          & \texttt{grDevices::pdf}      & \texttt{/ocpu/tmp/\{key\}/graphics/1/pdf}     \\
 \texttt{svg}    & \texttt{image/svg+xml}            & \texttt{grDevices::svg}      & \texttt{/ocpu/tmp/\{key\}/graphics/1/svg}     \\ \bottomrule
\end{tabular}
\caption{Supported object export formats and corresponding \texttt{Content-type}}
\label{table:formats}
\end{table}

\subsection{URLs}

The root of the API is dynamic. It defaults to \texttt{/ocpu/} however system administrators can change this. Clients should make the \OpenCPU server address and root path configurable. In the examples we assume the default \texttt{/ocpu/} is used. As discussed before, \OpenCPU currently implements two container types to hold resources. Table \ref{table:packageapi} lists the \texttt{URL}s of the \emph{package} container type, which includes objects, data, manual pages and files.

\begin{table}[H]
\centering
\def\arraystretch{1.3}%
\begin{tabular}{@{}lll@{}}
\toprule
\emph{Path} & \emph{Desription}                      & \emph{Examples}                \\ \midrule
\texttt{.}    & Package information                      & \texttt{/ocpu/cran/MASS/}               \\
\texttt{./R}    & Exported namespace objects             & \texttt{/ocpu/cran/MASS/R/}             \\
     &                                                   & \texttt{/ocpu/cran/MASS/R/rlm/print}    \\
\texttt{./data} & Data objects in the package (\HTTP \GET only)         & \texttt{/ocpu/cran/MASS/data/}          \\
     &                                                   & \texttt{/ocpu/cran/MASS/data/cats/json} \\
\texttt{./man}  & Manual pages in the package (\HTTP \GET only)         & \texttt{/ocpu/cran/MASS/man/}           \\
     &                                                   & \texttt{/ocpu/cran/MASS/man/rlm/html}   \\
\texttt{./*}    & Files in installation directory, relative to package the root      & \texttt{/ocpu/cran/MASS/NEWS}    \\
     &                                                   & \texttt{/ocpu/cran/MASS/scripts/}       \\ \bottomrule
\end{tabular}
\caption{The package container includes objects, data, manual pages and files.}
\label{table:packageapi}
\end{table}

Similarly table \ref{table:sessionapi} lists \texttt{URL}s of the \emph{session} container type. This container holds outputs generated from a \RPC request and includes objects, graphics, source code, stdout and files. Note that the distinction between packages and sessions is considered an implementation detail. The \API does not differentiate between objects and files that appear in packages or in sessions.


\begin{table}[H]
\centering
\def\arraystretch{1.3}%
\begin{tabular}{@{}lll@{}}
\toprule
\emph{Path}          & \emph{Desription}                      & \emph{Examples}                \\ 
\midrule
\texttt{.}          & Session content list                                       & \texttt{/ocpu/tmp/\{key\}/}               \\
\texttt{./R}        & Objects created by the \RPC request                        & \texttt{/ocpu/tmp/\{key\}/R/}             \\
                    &                                                            & \texttt{/ocpu/tmp/\{key\}/R/mydata/json}  \\
\texttt{./graphics} & Graphics created by the \RPC request                       & \texttt{/ocpu/tmp/\{key\}/graphics/}      \\
                    &                                                            & \texttt{/ocpu/tmp/\{key\}/graphics/1/png} \\
\texttt{./source}   & Source code of \RPC request                                & \texttt{/ocpu/tmp/\{key\}/source/}       \\
\texttt{./stdout}   & \texttt{STDOUT} from by the \RPC request                   & \texttt{/ocpu/tmp/\{key\}/stdout/}       \\
\texttt{./console}  & Mixed source and \texttt{STDOUT} emulating console output  & \texttt{/ocpu/tmp/\{key\}/console/}     \\
\texttt{./files/*}  & Files saved to working dir by the \RPC request             & \texttt{/ocpu/tmp/\{key\}/files/myfile.xyz}       \\

                                                
\bottomrule
\end{tabular}
\caption{The session container includes objects, graphics, source, stdout and files.}
\label{table:sessionapi}
\end{table}


\subsection{RPC requests}

A \POST request in \OpenCPU always invokes a remote procedure call (\RPC). Requests targeting a \emph{function} object result in a function call where the \HTTP parameters from the post body are mapped to function \emph{arguments}. Similarly, a \texttt{POST} targeting a \emph{script} results in execution of the script where \HTTP parameters are passed to the script interpreter. We use the term \RPC to refer to both remote function calls and remote script executions. The current \OpenCPU implementation recognizes scripts by their file extension, and supports \R, \texttt{latex}, \texttt{markdown}, \texttt{Sweave} and \texttt{knitr} scripts. Table \ref{table:scripts} lists each script type with the respective file extension.

\begin{table}[H]
\centering
\def\arraystretch{1.3}%
\begin{tabular}{@{}lll@{}}
\toprule
\emph{File extension} & \emph{Type}           & \emph{Interpreter}                   \\ \midrule
\texttt{file.r}         & \R       & \texttt{evaluate::evaluate}            \\
\texttt{file.tex}       & \Latex          & \texttt{tools::texi2pdf}               \\
\texttt{file.rnw}       & \texttt{knitr}/\texttt{sweave}   & \texttt{knitr::knit} + \texttt{tools::texi2pdf} \\
\texttt{file.md}        & \texttt{markdown}       & \texttt{knitr::pandoc}                 \\
\texttt{file.rmd}       & \texttt{knitr markdown} & \texttt{knitr::knit} + \texttt{knitr::pandoc}   \\
\texttt{file.brew}      & \texttt{brew}           & \texttt{brew::brew}                    \\ \bottomrule
\end{tabular}
\caption{Files recognzied as scripts and their characterizing file extension}
\label{table:scripts}
\end{table}

One conceptual difference with a terminal interface is that in the \OpenCPU \API, the server determines the namespace that output of a function call is assigned to. The server includes a temporary \emph{key} in the \RPC response that serves the same role as a variable name and is used to reference the newly created resources in future requests. This key is private and the client should treat it confidentially. Besides the return value, the server stores graphics, files, warnings, messages and \texttt{stdout} that were created during the function call. These contents can be listed and retrieved using the same key as for the object. In \R, the function call itself is also an object which is added to the collection for reproducibility purposes. Objects on the system are non mutable and therefore the client can not change or overwrite existing keys or objects. For function calls that modify the state of an object, the server creates a copy of the modified object under a new name and leaves the original unaffected.

\subsection{Arguments}

Arguments to a remote function call can be posted using one of several methods. A data interchange format such as \JSON or \texttt{Protocol Buffers} can be used to directly post data structures such as lists, vectors, matrices or data frames. Alternatively the client can reference an existing object on the server using a key or name. The server automatically resolves keys and converts data structures into native objects which are used as arguments in the function call. Hence the function that is called is not restricted to a particular data interchange format. Files can also be used as arguments within remote function calls. Any files contained in a \texttt{multipart/form-data}  post request will be copied to the working directory before the function call is executed. The server then sets the argument in the function call to the \texttt{filename}. Thereby we can remotely call functions with a file argument using standard \HTML form submission.

\begin{table}[H]
\centering
\def\arraystretch{1.3}%
\begin{tabular}{@{}llllll@{}}
\toprule
\emph{Content-type}                      & \emph{Primitives} & \emph{Data structures}  &  \emph{Raw code} & \emph{File} & \emph{Temp key} \\ \midrule
\texttt{multipart/form-data}               & OK         & OK (inline \texttt{json}) & OK       & OK   & OK            \\
\texttt{application/x-www-form-urlencoded} & OK         & OK (inline \texttt{json}) & OK       & -    & OK            \\
\texttt{application/json}                  & OK         & OK               & -        & -    & -             \\
\texttt{application/x-protobuf}            & OK         & OK               & -        & -    & -             \\ \bottomrule
\end{tabular}
\caption{Accepted request \texttt{Content-types} and supported argument formats}
\label{table:arguments}
\end{table}

The current implementation supports several \texttt{Content-type} formats for passing arguments to a remote function call within a \POST request. These include \texttt{application/x-www-form-urlencoded}, \texttt{multipart/form-data}, \texttt{application/json} and \texttt{application/x-protobuf}. Each parameter or top level object within a \POST requests contains an argument value. These values can be specified one of several argument formats as listed in table \ref{table:arguments}. Not every \texttt{Content-type} supports each argument format. Table \ref{table:arguments} shows a matrix of which \texttt{Content-types} support which argument formats.
